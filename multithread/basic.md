# Multithread


0. intro
    
        1). 线程, 进程, 程序
        2). 线程的创建 & 使用 (4中方式创建) *****
        3). 线程的声明周期 *** 
        4). 线程同步 (解决线程安全问题, 3种方式) *****
        5). 线程间通信 ***


1. 线程, 进程, 程序

        1). running program = process, process会占用系统资源, 每个进程有独立的方法区和堆空间
        2). thread: 程序内部的一条执行路径, 每条线程都有独立的运行栈和pc寄存器, 线程之间切换的开销很小; 一个进程会有多条线程, 共享内存资源(方法区, 堆空间), 多线程之间通信很方便, 但会产生线程安全隐患(线程同步)
        3). 一个java.exe至少有三个线程, main线程, gc线程, 异常处理线程
        4). 并行 vs 并发: 
                - 并行: 多个cpu同时执行多个任务
                - 并发: 一个cpu同时执行多个任务(时间切片快速切换)
        5). 何时需要多线程:
            
            首先, 以单核cpu执行多个任务为例, 单线程的执行完所有任务的速度要比"多线程"同时执行完多个任务速度快, 由于cpt切换线程会占用大量cpu资源
            
            单线程CPU如何执行"多线程"?
                - 单核cpu同一时间只能处理1个线程, 只有1个线程在执行
                - 多线程同时执行: 其实是cpu快速在多个线程之间切换造成的假象
                - cpu调度线程的时间足够快, 就造成了这种"多线程"的假象
                - 如果线程非常多, cpu会在n个线程之间切换, 消耗大量的cpu资源
            
            a. 需要同时执行两个或多个任务, eg: main线程, gc线程, 异常处理线程
            b. 执行一些需要等待的任务, eg: 用户输入, 文件读写, 网络操作, 搜索等以提高用户体验, case: 用户滑动手机时(thread_1)另一条线程(thread_2)负责装载新的page content
            
            
2. 线程的创建

        方式一: 继承Thread类
            - 创建一个类继承Thread类
            - 重写Thread类的run()方法, 子线程要做的事就放在这里
            - 创建这个子类的对象
            - 子类对象调用start()方法
            
![CreateThreadByInheritThreadClass](imagePool/CreateThreadByInheritThreadClass.png)

            注意: 
                a. start()的作用: 
                    - 启动子线程
                    - 调用子线程的run()方法
                b. 不能直接调用run()方法, 相当于没有多线程执行
                c. start()方法只能start一次, 不能让已经启动执行的子线程再start()子线程
